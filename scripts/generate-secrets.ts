#!/usr/bin/env bun

import { randomBytes } from "node:crypto";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname, resolve } from "node:path";

const OUTPUT_PATH = resolve(process.cwd(), "docker/.env.compose");
const FORCE_FLAG = process.argv.includes("--force");

if (!FORCE_FLAG && existsSync(OUTPUT_PATH)) {
	console.error(
		`Refusing to overwrite ${OUTPUT_PATH}. Pass --force to regenerate secrets.`
	);
	process.exit(1);
}

const managedKeys = [
	"POSTGRES_USER",
	"POSTGRES_PASSWORD",
	"POSTGRES_DB",
	"DATABASE_URL",
	"SHADOW_DATABASE_URL",
	"PG_PROXY_PASSWORD",
	"ELECTRIC__PG_PROXY__PASSWORD",
];

const INSECURE_PLACEHOLDER = "replace-with-strong-secret";

const preservedDefaults = new Map<string, () => string>([
	["ELECTRIC_GATEKEEPER_SECRET", () => randomSecret(32)],
]);

const existingEntries = new Map<string, string>();
const preservedKeyOrder: string[] = [];

if (existsSync(OUTPUT_PATH)) {
	for (const line of readFileSync(OUTPUT_PATH, "utf8").split(/\r?\n/)) {
		const equalsIndex = line.indexOf("=");
		if (equalsIndex === -1) {
			continue;
		}
		const key = line.slice(0, equalsIndex).trim();
		const value = line.slice(equalsIndex + 1);
		if (!key) {
			continue;
		}
		existingEntries.set(key, value);
		if (!managedKeys.includes(key) && !preservedKeyOrder.includes(key)) {
			preservedKeyOrder.push(key);
		}
	}
}

const randomSecret = (bytes: number) =>
	randomBytes(bytes).toString("base64url");

const existingDatabaseUrl = existingEntries.get("DATABASE_URL");
const existingShadowUrl = existingEntries.get("SHADOW_DATABASE_URL");

let pgUser = process.env.DOCKER_DATABASE_USER ?? existingEntries.get("POSTGRES_USER") ?? "ochat_app";
let dbName = process.env.DOCKER_DATABASE_NAME ?? existingEntries.get("POSTGRES_DB") ?? "openchat";
let dbHost = process.env.DOCKER_DATABASE_HOST ?? "postgres";
let dbPort = process.env.DOCKER_DATABASE_PORT ?? "5432";
let shadowDbName = `${dbName}_shadow`;

if (existingDatabaseUrl) {
	try {
		const url = new URL(existingDatabaseUrl);
		if (url.username) {
			pgUser = decodeURIComponent(url.username);
		}
		if (url.hostname) {
			dbHost = url.hostname;
		}
		if (url.port) {
			dbPort = url.port;
		}
		if (url.pathname && url.pathname !== "/") {
			dbName = url.pathname.slice(1);
		}
	} catch {
		// ignore malformed URLs and continue with defaults
	}
}

if (existingShadowUrl) {
	try {
		const url = new URL(existingShadowUrl);
		if (url.pathname && url.pathname !== "/") {
			shadowDbName = url.pathname.slice(1);
		}
	} catch {
		// ignore malformed URLs
	}
}

const postgresPassword = randomSecret(32);
const pgProxyPassword = randomSecret(32);

const encodedUser = encodeURIComponent(pgUser);
const encodedPassword = encodeURIComponent(postgresPassword);

const databaseUrl = `postgres://${encodedUser}:${encodedPassword}@${dbHost}:${dbPort}/${dbName}`;
const shadowDatabaseUrl = `postgres://${encodedUser}:${encodedPassword}@${dbHost}:${dbPort}/${shadowDbName}`;

const managedEntries = new Map<string, string>([
	["POSTGRES_USER", pgUser],
	["POSTGRES_PASSWORD", postgresPassword],
	["POSTGRES_DB", dbName],
	["DATABASE_URL", databaseUrl],
	["SHADOW_DATABASE_URL", shadowDatabaseUrl],
	["PG_PROXY_PASSWORD", pgProxyPassword],
	["ELECTRIC__PG_PROXY__PASSWORD", pgProxyPassword],
]);

const commandHint = `bun run generate:secrets${FORCE_FLAG ? "" : " --force"}`;
const lines: string[] = [
	"# Autogenerated by scripts/generate-secrets.ts",
	`# Run "${commandHint}" to refresh database credentials.`,
];

for (const key of managedKeys) {
	lines.push(`${key}=${managedEntries.get(key)}`);
}

const preservedKeys = new Map<string, string>();
for (const key of preservedKeyOrder) {
	const value = existingEntries.get(key);
	if (value !== undefined && !managedEntries.has(key)) {
		preservedKeys.set(key, value);
	}
}

for (const [key, generateSecret] of preservedDefaults) {
	const existing = preservedKeys.get(key);
	if (!existing) {
		// No existing value — generate a secure random secret
		preservedKeys.set(key, generateSecret());
		preservedKeyOrder.push(key);
	} else if (existing === INSECURE_PLACEHOLDER) {
		// Replace the old insecure placeholder with a proper secret
		console.warn(
			`⚠️  Replacing insecure placeholder for ${key} with a generated secret.`,
		);
		preservedKeys.set(key, generateSecret());
	}
}

if (preservedKeyOrder.length > 0) {
	lines.push("", "# Non-database secrets are preserved below. Edit them manually as needed.");
	for (const key of preservedKeyOrder) {
		const value = preservedKeys.get(key);
		if (value !== undefined) {
			lines.push(`${key}=${value}`);
		}
	}
}

// Validate that no insecure placeholder values remain in the output
for (const [key] of preservedDefaults) {
	const value = preservedKeys.get(key);
	if (value === INSECURE_PLACEHOLDER) {
		console.error(
			`❌ ELECTRIC_GATEKEEPER_SECRET still contains the insecure placeholder value. Aborting.`,
		);
		process.exit(1);
	}
}

const fileContents = `${lines.join("\n")}\n`;

mkdirSync(dirname(OUTPUT_PATH), { recursive: true });
writeFileSync(OUTPUT_PATH, fileContents, { encoding: "utf8" });

console.log(`✅ Wrote secrets to ${OUTPUT_PATH}`);
